---
title: "Datenanalyse in R mit data.table"
author: "Tim Graf"
date: "06. Oktober 2016"
output: 
    ioslides_presentation:
        widescreen: true
css: slide.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

```

## Was ist ein data.table?
<div class="textbox">
Das R-Paket *data.table* ist eine verbesserte und erweitere Form des *data.frame*. 
</div>

<table class="image">
<tr>
<td><img src="dowle.jpg" width="300" height="300"></td>
<td width="400"></td>
<td><img src="arun.png" width="300" height="300"></td>
</tr>
<tr>
<td>Matt Dowle</td>
<td></td>
<td align="right">Arun Srinivasan</td>
</tr>
</table>

## Workshop

* Hands-On Einführung in `data.table`
* Wichtige Konzepte und Befehle
* Schwerpunkte:
    + Daten zusammenfassen
    + Daten ändern
* Leider keine Schwerpunkte
    + Joins von verschiedenen Datenquellen
    + Reshaping

## Warum data.table?

- `fread()` ist die schnellste, einfachste und anpassbarste Lesefunktion für Daten aus externen Tabellen. 
- schnell 
- sparsam (Arbeitsspeicher)
- Eine Syntax für alles

## Daten einlesen

Einlesen von Eyetracking-Daten. 20 Spalten, 10287016 Zeilen, etwa 800 MB

```{r normal_csv, echo = TRUE, cache = TRUE}

system.time(df <- read.table("Zyklop4_Freq.txt", header = TRUE))

```

```{r loading, echo = TRUE}
library(data.table)
```

```{r fread, echo = TRUE, cache = TRUE}
system.time(dt <- fread("Zyklop4_Freq.txt", showProgress = FALSE))
```


## data.table-Syntax

<div class="examplecode">
DT[<span style="color:green">i</span> , <span style="color:red">j</span> , <span style="color:blue">by</span>]
</div>

Was passiert an den drei Stellen?

>- <span style="color:green">i</span>: Auswahl eines Subsets von Zeilen 
>- <span style="color:red">j</span>: Auswahl von Spalten (Variablen)
>- <span style="color:blue">by</span>: Gruppierung anhand von Faktoren

Was für einen Input benötigen die Stellen?

>- <span style="color:green">i</span>: Logischer Ausdruck / Key 
>- <span style="color:red">j</span>: Variablennamen als Liste / Zuweisungsoperator
>- <span style="color:blue">by</span>: Variablennamen als Liste



## Übungsdatenset

- Inspiriert von *self-paced reading* oder *speeded accuracy tradeoff*
- **subject**: Teilnehmer-ID
- **phase**: Erste oder zweite Teilnahme 
- **trial**: Durchlauf des Experiments
- **cond**: Experimentelle Bedingung (ambig, eindeutig, filler)
- **rt1, rt2, rt3**: Reaktionszeiten an drei Stellen im Trial 


Einlesen der Daten mit `fread()`

```{r read_data_test, echo = TRUE}

dt <- fread("test_data.csv")

```


## Ein kurzer Überblick 

```{r show_test_data, echo = TRUE}

dt

```


## Ein kurzer Überblick 

```{r, echo = TRUE}
str(dt)

c(is.data.table(dt), is.data.frame(dt))

```

## Zeilen-Subsets: <span style="color:green">i</span> 

Zeile 12-15 

```{r, tidy = TRUE, echo = TRUE}
dt[12:15]
```


## Zeilen-Subsets: <span style="color:green">i</span> 

Alle Zeilen von Teilnehmer 10
```{r, echo = TRUE}
dt[subject == 10]
```


## Zeilen-Subsets: <span style="color:green">i</span> 

Alle Zeilen in denen rt2 kleiner als 90 ms ist
```{r, echo = TRUE}
dt[rt2 < 90]
```

## Eine Spalte auswählen: <span style="color:red">j</span> {.smaller}

**Spalte rt1 als Vektor (Die ersten 6 Elemente)**

```{r, echo = TRUE}

head(dt[, rt1])

```


**Spalte rt1 als Liste / DT (Die ersten 6 Elemente)**

```{r, echo = TRUE}

head(dt[, .(rt1)])

```

## Mehrere Spalten auswählen: <span style="color:red">j</span> {.smaller}


```{r, echo = TRUE}
head(dt[, .(rt1, rt2, rt3)], 3)
```


```{r, echo = TRUE}
head(dt[, c("rt1", "rt2", "rt3"), with=FALSE], 3)
```


```{r, echo = TRUE}
head(dt[, 4:6, with=FALSE], 3)
```

## Gruppierung anhand von Faktoren: <span style="color:blue">by</span> 

>- Wie erstellt man Statistiken für verschiedene Datengruppen?
>- Standard R: `split()` und `apply()` 
>- `data.table`: Einheitliche Syntax mit <span style="color:blue">by</span>
>- Alternativen: Hadley Wickhams `dplyr`-Paket
 



## Einfaches Beispiel {.smaller}

Mittelwert der Reaktionszeit in Abhängigkeit von Bedingung.

**Standard R**

```{r, echo = TRUE}

with(dt, lapply(split(rt1, cond), mean, na.rm=TRUE))

```

**Data.table**

```{r, echo = TRUE}

dt[, .(mean_rt = mean(rt1, na.rm = TRUE)), .(cond) ]

```

## Nicht so einfaches Beispiel mit Standard R: 

Mittelwert und Standardabweichung der Reaktionszeit in Abhängigkeit von Bedingung und Phase


```{r, echo = TRUE, eval=TRUE}

with(dt, sapply(split(rt1, list(cond, phase)), mean, na.rm=TRUE))
with(dt, sapply(split(rt1, list(cond, phase)), sd, na.rm=TRUE))

```


## Data.table: <span style="color:blue">by</span> 


**Data.table**

```{r, echo = TRUE}

dt[, .(mean_rt = mean(rt1, na.rm = TRUE),
       sd_rt = sd(rt1, na.rm = TRUE)), .(cond, phase) ]

```

## Kompliziertes Beispiel mit Standard R: {.smaller}

Mittelwert für alle Reaktionszeiten in Abhängigkeit von Bedingung und Phase


```{r, echo = TRUE, eval=TRUE}

with(dt, sapply(split(rt1, list(cond, phase)), mean, na.rm=TRUE))
with(dt, sapply(split(rt2, list(cond, phase)), mean, na.rm=TRUE))
with(dt, sapply(split(rt3, list(cond, phase)), mean, na.rm=TRUE))

```




## Data.table. <span style="color:blue">by</span> und .SD {.smaller}


**Data.table**

* `.SD` steht für alle Spalten auf die eine Funktion angewendet werden soll
* `.SDcols` legt diese Spalten fest

```{r, echo = TRUE}

dt[, lapply(.SD, mean, na.rm = TRUE), .(cond, phase), .SDcols = c("rt1", "rt2", "rt3")]

```


## Zeilen zählen mit .N 

Oftmals möchte man wissen, wie viele Beobachtungen es für eine bestimmte Kombination von Variablen gibt. Hier hilft `.N`

```{r, echo = TRUE}
dt[, .N] 
nrow(dt)

dt[, .N, .(cond)]
```

## Übung 1

<div align=center>**Es ist Zeit für eine kurze Übung**</div>

## Werte verändern - Der `:=` - Operator

* Werte werden in <span style="color:red">j</span> verändert.
* `=` wird bereits genutzt
* Zum Zuweisen von Werten wird der `:=` - Operator genutzt.
* Dieser steht auch als Funktion zur Verfügung, wenn mehrere Spalten gleichzeitig verändert werden sollen.


## Ein paar Beispiele {.smaller} 

**Eine neue Spalte erzeugen (Konstante)**

```{r, echo = TRUE}
dt[, konstante := 1]
head(dt, 3)
```

**Eine neue Spalte erzeugen (Funktion)**

```{r}
dt[, konstante := NULL]
```


```{r, echo = TRUE}
dt[, centered_trial := scale(trial, scale = FALSE)]
head(dt, 3)
```

## Ein paar Beispiele {.smaller}

**Eine Spalte verändern**

```{r, echo = TRUE}
dt[, phase := factor(phase, labels = c("First", "Second"))]
head(dt, 3)
```

**Eine Spalte löschen**

```{r, echo = TRUE}
dt[, centered_trial := NULL]
head(dt, 3)
```

## Mehrere Werte zuweisen

Eventuell möchte man sich gerne die logarithmierten RTs ansehen und diese Werte als neue Spalten in den data.table einfügen

```{r, echo = TRUE, warning=FALSE}
dt[, `:=`(log_rt1 = log(rt1), 
          log_rt2 = log(rt2),
          log_rt3 = log(rt3))]

head(dt, 3)
```

## Werte in Abhängigkeit von Gruppen

**`:=` und <span style="color:blue">by</span>**

Beispiel: Normalisierte RT pro Proband

```{r}
dt[, c("log_rt1", "log_rt2", "log_rt3") := NULL, with = FALSE]
```

```{r, echo = TRUE, eval = FALSE}

dt[, rt1_scaled := scale(rt1), .(subject)]

```


**Verändern der Werte für ein Subset**

Addieren einer Konstante zur SubjectID um diese nachher besser ausschließen zu können.

```{r, echo = TRUE}

dt[subject == 1, subject := subject + 900L ]
head(dt,3)

```


## Übung 2


<div align=center>**Es ist Zeit für eine kurze Übung**</div>

## Keys

* Keys sind Zeilennamen mit Superkräften
* Ermöglichen das schnelle Subsetten bei sehr großen Datentabellen

* Keys für Spalten werden mit `setkey()` gesetzt
* Der `data.table` wird nach dieser Spalte sortiert


## Ein `key`-Beispiel {.smaller}

```{r, echo = TRUE}
dt[1:6]

setkey(dt, cond)

dt[1:6]

```




## Schnelles Subsetten - Ein Wert


```{r, echo = TRUE}

dt["ambig"]

```


## Schnelles Subsetten - Mehrere Werte


```{r, echo = TRUE}

dt[c("ambig", "filler")]

```

## Ein Key für mehrere Spalten 

```{r, echo = TRUE}
setkeyv(dt, c("cond", "phase"))

dt[.("ambig", "First")]

```

## Ein paar Beispiele für den Einsatz von Keys {.smaller}


```{r, echo = TRUE}
setkey(dt, cond)
dt["ambig", max(rt1, na.rm = TRUE)]
dt["eindeutig", min(rt2, na.rm = TRUE), .(subject)][1:10]
```

## Ein paar Beispiele für den Einsatz von Keys 

```{r, echo = TRUE}
setkeyv(dt, c("cond", "phase"))
dt[.("ambig", "First"), max(rt3, na.rm = TRUE) , .(subject)][1:10]

```

## Verketten von Befehlen

* Es ist möglich, mehrere `data.table`-Operationen zu verketten. 
* Aus Gründen der Nachvollziehbarkeit sollte damit aber nicht übertrieben werden. 
* Nützlich um neu erstellte Spalten zusammen zu fassen oder Subsets anzuzeigen.

>- Zum Verketten einfach eine weitere Klammer anfügen dt[<span style="color:green">i</span> , <span style="color:red">j</span> , <span style="color:blue">by</span>][<span style="color:green">i</span> , <span style="color:red">j</span> , <span style="color:blue">by</span>]

## Beispiel: Verkettung

* Log von rt1 erstellen
* Maximum von log_rt1 pro Proband finden
* Nur die Werte jedes zweiten Probanden anzeigen



```{r, echo = TRUE, warning= FALSE}

dt[, log_rt1 := log(rt1)][, max(log_rt1, na.rm = TRUE), .(subject)][subject %in% seq(1,20, 2)]

```

## Übung 3


<div align=center>**Es ist Zeit für eine letzte Übung**</div>



## Weitere Quellen zu data.table

```{r, echo = TRUE, eval = FALSE}
vignette("datatable-intro-vignette")
vignette("datatable-reference-semantics")
vignette("datatable-keys-fast-subset")
vignette("datatable-reshape")
```

* [Github-Webseite des Pakets](https://github.com/Rdatatable/data.table/wiki/Getting-started)
* [Datacamp](http://www.datacamp.com)
 + Basics sind kostenlos
 + Weiterführende Kurse für etwa 25 $
* [Cheat Sheet](https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf)


## Vielen Dank

![](business-tips.png)

